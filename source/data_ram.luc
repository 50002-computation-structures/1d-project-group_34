module data_ram #(
    ROW_DIMENSION = 4 : ROW_DIMENSION > 0,
    COLUMN_DIMENSION = 4 : COLUMN_DIMENSION > 0,
    ENCODING_AMOUNT = 4 : ENCODING_AMOUNT > 0
    )(
    input clk,  // clock
    input rst,  // reset
    input update,
    input player_x_pos[2],
    input player_y_pos[2],
    input address[$clog2(ROW_DIMENSION*COLUMN_DIMENSION)],
    //input start_button,
    output out_encoding[2],
    output ready,
    output debug_address_pointer[$clog2(ROW_DIMENSION*COLUMN_DIMENSION)],
    output debug_data[3]
  ) {
  
  const DEPTH =  COLUMN_DIMENSION * ROW_DIMENSION;
  fsm writer(.clk(clk), .rst(rst)) = {
    INIT, 
    WRITE,
    ERASE, 
    CHECK,
    LOSE,
    IDLE
    };
  dff writer_pointer[$clog2(DEPTH)](#INIT(0),.clk(clk), .rst(rst));
  dff update_flag(#INIT(0), .clk(clk), .rst(rst));
  //dff counter[27](.clk(clk), .rst(rst), #INIT(0)); //can use to stop flashing map
  
  const BACKGROUND_COLOR = b00;
  const PLAYER_COLOR = b11;
  const LOSE_COLOR = b01;
  map_rom mapRom;
  simple_dual_ram ram(.rclk(clk), .wclk(clk), #DEPTH(DEPTH), #SIZE($clog2(ENCODING_AMOUNT)));
  var i;
  
  always {
    ram.raddr = 0;
    ram.waddr = 0;
    ram.write_data = 0;
    ram.write_en = 0;
    mapRom.map_num = 0;
    //mapRom.map_num = au_top.rom_address;


    out_encoding = 0;
    debug_data = 0;
    
    ready = writer.q == writer.IDLE;
    debug_address_pointer = writer_pointer.q;
    
    // always catch any positive update request 
    if (update){
      update_flag.d = update;
    }
    
    case (writer.q){
      writer.INIT: 
        ram.write_en = b1; 
        ram.waddr = writer_pointer.q;
        
        for (i=0; i<16;i++){
        if (writer_pointer.q == i){
          ram.write_data = mapRom.out_encoding[i];
          }
        }
        writer_pointer.d = writer_pointer.q + 1; 
        if (&writer_pointer.q){
          // advanced to write 
          writer.d = writer.WRITE;
          // set writer pointer to player position 
          writer_pointer.d = player_y_pos*4 + player_x_pos;
        }
        
        
      writer.ERASE: 
        ram.write_en = b1; 
        ram.waddr = writer_pointer.q; // this is old player address 
        ram.write_data = BACKGROUND_COLOR; // set back to background color 
        //writer.d = writer.ERASE_TOP_LEFT;
        writer.d = writer.WRITE;
        writer_pointer.d = player_y_pos*4 + player_x_pos; // update player position +
           
      writer.WRITE:
        ram.write_en = b1; // enable the dual ram write
        ram.waddr = writer_pointer.q; // write to the respective address
        ram.write_data = PLAYER_COLOR; // write player position (red)_
        //writer.d = writer.WRITE_TOP_LEFT;
        //writer.d = writer.CHECK;
        writer.d = writer.CHECK;
        debug_data = b10;
       
      writer.CHECK:
        ram.write_en = b0;
        if (mapRom.out_encoding[writer_pointer.q] == b01){ //if current location is red,
          writer.d = writer.LOSE;
        }
        else{
        writer.d = writer.IDLE;
        //writer_pointer.d = player_y_pos*4 + player_x_pos;
        }
        debug_data = b01;
        
      writer.LOSE:
        ram.write_en = b1; 
        ram.waddr = writer_pointer.q;
        
        for (i=0; i<16;i++){
        if (writer_pointer.q == i){
          ram.write_data = LOSE_COLOR;
          }
        }
        writer_pointer.d = writer_pointer.q + 1; 
        debug_data = b001;
        ram.raddr = address;
        out_encoding = ram.read_data;
        
    
        
      /*writer.CHECK:
        ram.raddr = address;
        //out_encoding = ram.read_data;
        ram.write_en = b1; 
        ram.waddr = writer_pointer.q;
        
        if (mapRom.out_encoding[writer_pointer.q] == b01){
        if (ram.read_data == b01){ //red
          for (i=0; i<16;i++){ //flash all red
          if (writer_pointer.q == i){
            ram.write_data = b01;
            }
       }}
          if (ram.read_data == b10){ //green
          for (i=0; i<16;i++){ //flash all green
          if (writer_pointer.q == i){
            ram.write_data = b10;
            }
       }}
          writer_pointer.d = writer_pointer.q + 1; 
            if (&writer_pointer.q){
          writer.d = writer.IDLE;
          writer_pointer.d = player_y_pos*4 + player_x_pos;}*/
        
          
      writer.IDLE:
        ram.raddr = address;
        out_encoding = ram.read_data;
        debug_data = 0; // for debugging
        writer.d = writer.IDLE; // remain in state
        if (update_flag.q){
            update_flag.d = 0;
            writer.d = writer.ERASE;
        }
        debug_data = c{b11, update_flag.q};
      
    }
    
  }
}
